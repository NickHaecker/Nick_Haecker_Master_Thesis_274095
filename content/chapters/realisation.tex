\chapter{Umsetzung des Prototyps}
Nachdem in Kapitel \ref{sec:concept} die Konzeption der Anwendung vorgestellt wurde kann, kann nun die Umsetzung der Anwendungen erfolgen.

Zunächst wird dabei auf die Ausgangssituation aus dem vorangegangenem Projekt vorgestellt. Im Anschluss erfolgt eine Auflistung der verwendeten Technologien. Danach erfolgt die Vorstellung der Anwendungen, sowie die Herausforderungen und Probleme in der Umsetzung

\section{Ausgangssituation}
In der vorausgehenden Arbeit wurde ein Art \ac{MVP} der Spielidee umgesetzt welche aus 3 Hauptanwendungen bestand. Es gibt eine Unity-Anwendung, in welcher das Spielgeschehen des \say{Players} umgesetzt wurde. Das Spielgeschehen der \say{Watcher}-Anwendung wurde über eine Vue3-Webseite realisiert. Für die Kommunikation der beiden Anwendungen untereinander wurde auf der Basis eines \say{Express.js} Node-Servers ein WebSocket-Server entwickelt. Der Node-WebSocket-Server kommuniziert zusätzlich mit einer MongoDB Datenbank, in welcher die Fortschritte der einzelnen Sessions gespeichert werden.

Die Anwendungen des \say{Players} und des \say{Watchers} sind in dieser Konstellation jeweils Anzeigende und auf die Eingaben des Nutzers reagierende Komponenten im gesamten System. Sie geben eine Rückmeldung an den Server, der die Daten zur Laufzeit abspeichert und persistent in einer Datenbank speichern kann.

\subsection{Aufbau der Ausgangssituation}

Im Softwaredesign wird dabei von einem \ac{MVC} Design-Pattern gesprochen (vgl. \cite{GlossarWiki:Reenskaug:1979a}). 
Das Model definiert, welche Daten die App enthalten soll. Ändert sich der Zustand dieser Daten, informiert das Modell die einzelnen Views, damit die Ansicht der Daten entsprechend aktualisiert werden können. Außerdem wird manchmal auch der Controller über Änderungen informiert. Die View definiert wie die Daten angezeigt werden sollen. Der Controller verarbeitet die reinkommenden Änderungen aus den Views, die die Nutzer getätigt haben, und gibt diese an das Model oder die Views direkt weiter (vgl. \cite{noauthor_mvc_2023}); (vgl. Abbildung \ref{fig:mvc-diagramm}).

\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{content/pictures/mvc-architecture.png}
\caption{\ac{MVC} Beispiel-Diagramm \cite{noauthor_mvc_2023}}
\label{fig:mvc-diagramm}
\end{figure}

Die MongoDB Datenbank und Klassen innerhalb des WebSocket-Servers nehmen die Rolle des Model ein, die einzelnen WebSocket-Nachricht Endpunkte übernehmen die Aufgaben des Controllers und die Anwendung des \say{Watchers} und des \say{Players} sind die Views der Architektur.

\subsection{Beitreten einer Session}

\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{content/pictures/Login_Login_by_ID.png}
\caption{Startbildschirme der Player und Watcher Anwendung (Quelle: eigene Darstellung)}
\label{fig:old-logins}
\end{figure}

Abbildung \ref{fig:old-logins} zeigt den bereits im alten Prototyp entwickelten Startbildschirm über welchen der Player eine neue Session starten (linkes Bild, links oben) und der Watcher dieser beitreten kann (linkes Bild, rechts unten). Sobald der Player eine Session erstellt hat, erhält er vom WebSocket-Server eine Rückmeldung mit der erstellten Session-ID (rechtes Bild, links oben) welches er dem Watcher mitteilen muss, damit dieser ihr beitreten kann (rechts Bild, rechts unten).

\subsection{Einführung in die Anwendungen}

\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{content/pictures/Introduction.png}
\caption{Einführung in die Anwendung des Players und Watchers (Quelle: eigene Darstellung)}
\label{fig:old-introductions}
\end{figure}

Abbildung \ref{fig:old-introductions} zeigt die Einführung der beiden Anwendungen in die Spielwelt. Zum Start erhielt der Watcher einzelne Tooltips, mit Erklärungen zu den Grundfunktionen seiner Anwendung (erstes bis drittes Bild in der ersten Zeile und linkes Bild in der zweiten Zeile; jeweils in weiß umrandet im rechten Bildelement). Seine Anwendung enthalten zwei Dropdown-Menüs, über die Gegenstände und Positionen ausgewählt werden können, (erste Zeile, Bilder links und und in der Mitte) eine Liste mit allen platzierten Gegenstände (erste Zeile rechts Bild), die jeweils einzeln entfernt werden können und eine Top-Down-Ansicht der Spielwelt, in der sich der Player befindet (zweite Zeile, linkes Bild). 

Der Player steuert seinen Avatar über eine Touch-druck auf die Spielwelt (zweite Reihe mittlere Bild, linkes Bildelement). Außerdem kann er über vertikale Swipes die Höher der Kamera zum Avatar verändern und dadurch in einem gewissen Rahmen die Ansicht verändern.

Um in der Spielwelt an das Ziel zu gelangen, müssen der Player und Watcher zusammenarbeiten und Hindernisse in der Spielwelt beseitigen. Im linken Bild in der zweiten Zeile im weiß umrandeten wird ein solches Rätselelement dargestellt, welches gelöst werden muss.
\subsection{Lösen von Rätseln}
Wie wurden im alten Prototyp die einzelnen Rätsel gelöst und durch wen erfolgte dies?

\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{content/pictures/HowToSolve.png}
\caption{Vorgang des Lösens von Rätseln (Quelle: eigene Darstellung)}
\label{fig:old-solving-riddle}
\end{figure}

Der Watcher war dafür verantwortlich, dass Gegenstände auf ihre richtigen Zielpositionen platziert wurden. Sobald der Player auf eine Absperrung in der Spielwelt stieß, musste er beschreiben was er sah um dem Watcher einen Hinweis darauf zu geben, welche Gegenstände platziert werden müssen und auf welche Positionen diese gehören. Zunächst wählt der Watcher über das Gegenstände-Dropdown einen entsprechenden Gegenstand aus (linkes Bild, rechtes Bildelement). Anschließend wählt er eine vorgegebene Position aus, die im derzeitig aktiven Abschnitt der Spielwelt hinzugekommen ist (mittlere Bild, rechts Bildelement). Über den Button \say{Gegenstand platzieren} (linker Button) wird der Gegenstand in die Spielwelt des Players platziert. Sowohl der Player als auch der Watcher erhalten vom System eine Benachrichtigung, dass der Gegenstand platziert wurde (rechts Bild, beide weißen Umrandungen). Auf der rechten Seite der Watcher-Anwendung erscheint zur selben Zeit wie die Benachrichtigung der platzierte Gegenstand in der Liste der platzierten Gegenstände (rechtes Bild, rechtes Bildelement). 

\subsection{Freischalten von Gegenständen und Positionen}
Sobald ein Rätsel durch das Platzieren von Gegenständen gelöst wurde, erhielten Player und Watcher die Information, dass neue Gegenstände freigeschaltet wurden (vgl. Abbildung \ref{fig:old-unlock-system}, erste Reihe linkes Bild, eingekreist in weiß). 

\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{content/pictures/UnlockMore.png}
\caption{Freischalten neuer Gegenstände (Quelle: eigene Darstellung)}
\label{fig:old-unlock-system}
\end{figure}

Sobald das Lösen des Rätsel das Hindernis beseitigt und einen neuen Bereich zugänglich macht, geht der Bilder-Slider in der Anwendung des Watchers auf das aktuelle Bild. Der Slider zeigt dem Watcher alle verfügbaren Abschnitte der Spielwelt (vgl. erste Reihe, rechtes Bild, in weiß umrandet in Abbildung \ref{fig:old-unlock-system}). Durch die neuen Spielabschnitte werden nicht nur neue Gegenstände freigeschaltet, sondern auch zusätzliche vordefinierte Positionen, auf denen die Gegenstände platziert werden können. Diese werden dem Watcher in den Gegenstand- und Positions-Dropdown aufgelistet (vgl. Abbildung \ref{fig:old-unlock-system}, beide Bilder in der zweiten Reihe in weiß umrandet). 

\subsection{Aspekte zum Überarbeiten}
\paragraph{Backfaces}
In den zuvor betrachteten Abbildungen \ref{fig:old-logins} bis \ref{fig:old-unlock-system} fällt auf, dass die Wände der Spielwelt, in der sich der Player befindet (jeweils immer das linke Bildelement), \say{eigenartig} aussehen. Das liegt daran, dass die einzelnen Raum-Elemente dafür gedacht sind, dass durch die Kameraperspektive der Spieler im inneren des Raumes zu sein sollte. Man müsste für diesem Raumaufbau eine First-Person Kameraansicht wählen.

\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{content/pictures/Backfaces.png}
\caption{Fehlende Rückwand-Oberflächen in den Raummodellen (Quelle: eigene Darstellung), (Modell von \cite{alasl_autolevel_nodate})}
\label{fig:missing-backfaces}
\end{figure}

Abbildung \ref{fig:missing-backfaces} zeigt fehlende Rückseiten-Oberflächen an. Die blauen Oberflächen sind die Oberflächen, die durch ihre Ausrichtung der Normalvektoren von der Game-Engine gerendert werden können. Die roten Oberflächen sind die, die von der Game-Engine nicht berücksichtigt werden. Hierbei kann es zwei unterschiedliche Ansätze geben, fehlende Rückseiten hinzuzufügen. Innerhalb der Material-Konfiguration der einzelnen Materialien kann bi-direktionales Rendering aktiviert werden oder das Modell muss pro Richtung auf die auf das Modell geschaut wird jeweils eine Oberfläche haben, die auch in diese Richtung zeigt.

Außerdem müsste für den Anwendungszweck eines Spiel mit einer Top-Down Ansicht auch eine Decke der Räume entfernt werden, da diese für den Spieler nicht sichtbar sein sollte und sonst stören würde.

% backfaces

\paragraph{Steuerung des Avatars}
Im vorangegangenem Prototyp wurde wenig Aufmerksamkeit auf die Gestaltung der Spielsteuerung über Touch-Inputs gelegt. Die Standard-Steuerung innerhalb des verwendeten Unity-Assets von \cite{alasl_autolevel_nodate} enthielt zum Start des Projekts nur die Steuerung über Maus und Tastatur. Über die Tastatur konnte sich über die Spielwelt hinweg bewegt werden, ähnlich wie es aus \ac{RTS}-Spielen bekannt ist. Über die linke Maustaste konnte in die Spielwelt geklickt werden, wodurch sich der Spieler-Avatar an diese Stelle selbständig bewegte. Eine Steuerung über Touch-Eingaben an einem Touch-Monitor oder Fernseher musste erst eingebaut werden. Das Asset von \cite{alasl_autolevel_nodate} verwendet das Kamera-System der Cinemachine (vgl. \cite{noauthor_about_nodate}) wodurch einige vorgefertigte Steuerungen der Kamera durch die Maus bereits implementiert sind. 

Es fehlte also die Touchsteuerung. Diese wurde allerdings nicht nach den Funktionalitäten eines Touchscreens konzipiert und umgesetzt, wie es bspw. in der Arbeit von \cite[S. 64ff]{reinhard_augmented_2022} aufgezeigt wurde, sondern über eigene Ideen, die nicht den Komfort der Maussteuerung wiedergeben konnte. Durch existierende und nicht sichtbare Oberflächen in der Spielwelt, wurde ebenfalls die Erfolgschance den Avatar durch einen Touch-Klick in die Spielwelt zu bewegen vermindert, wodurch ebenfalls Spielkomfort verloren ging.

% steuerung beim Player

\paragraph{Interaktion mit der Spielwelt}
Sowohl die Anwendung des Players als auch die des Watchers besitzen wenig, bis keine Interaktionen mit der Spielwelt. Bei der Anwendung des Players besteht lediglich das Laufen innerhalb der Spielwelt als Interaktion. Der Watcher hingegen besaß keine Funktionalität im Bezug auf die Spielwelt. Lediglich die Menüs, über die die Daten der Session bearbeitet werden konnten. Für einen zukünftigen Prototyp müssen mehr Kernfunktionen in die Anwendungen eingebaut und Interaktionen mit der Spielwelt geschaffen werden.

% interaktion mit der spielwelt beim watcher
% feedback von den probandentests aufzählen

\paragraph{Sonstiges Feedback aus den Probandentests}
\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{content/pictures/Handlungsempfehlungen.PNG}
\caption{Handlungsempfehlungen des alten Prototyps (Quelle: eigene Darstellung aus der Abschlusspräsentation), (ganze Präsentation in Anhang \ref{}, S. 33)}
\label{fig:recommended-action}
\end{figure}

Abbildung \ref{fig:recommended-action} zeigt die Handlungsempfehlungen für den alten Prototyp aus der vorangegangenen Arbeit. Die Abschnitte der \say{Player Interaktion}, \say{Player Ansicht}, \say{Kamerasteuerung} und \say{Watcher Ansicht} wurden bereits angesprochen. Die Abschnitte \say{Environment} und \say{Watcher Tutorial} fehlen noch, wobei \say{Watcher Tutorial} in der Weiterentwicklung des Prototyps in der Implementierung keine Beachtung geschenkt wurde, da der Umfang ein eingebautes Tutorial für \ac{UI}-Elemente zu konzipieren und umzusetzen zu aufwändig wäre. Es müsste außerdem auch für die Anwendung des Player gälten.

Daher wird nun noch der Fokus auf das Environment gelegt. Die Handlungsempfehlungen beziehen sich in der Darstellung auf das bestehende System des Prototyps. Abstrahiert betrachtet ermöglicht eine grundlegende Weiterentwicklung der Anwendungen und des Environment neue Möglichkeiten wie Rätsel innerhalb der Spielwelt konzipiert und umgesetzt werden können. Dadurch kann es frei wählbare Positionen auf der Spielkarte geben, die nicht mehr vordefiniert sein müssen, oder dass bestehende Gegenstände auf irgend eine weise verändert werden müssen. Diese Aspekte könnten in einer neu Entwicklung des Environments anders aufgebaut werden.

\section{Verwendete Technologien}
In der folgenden Aufzählung werden alle externen Assets und Packages vorgestellt, welche in der Entwicklung des Prototyps verwendet wurden. Manche der Assets werden im Registry des Projekts nicht aufgezählt, da diese in einem Test-Projekt importiert und für den Gebrauch dieses Projekt in jeweilige Submodule editiert importiert wurden. 

\subsection{Unity Editor Version 2022.3.45f1}
Der Prototyp wurde mit der 2022.3.45f1 \ac{LTS}-Version umgesetzt, da diese zum Start der Masterarbeit die aktuelle 2022 \ac{LTS}-Version war. Zwischenzeitlich wurde auch die 2023.2.20f1 (vgl. \cite{noauthor_unity_nodate}) ausprobiert. Da diese allerdings weder eine \ac{LTS}-Version noch zusätzlich im Package der Cinemachine ein Major-Update enthalten war und die Cinemachine einige Probleme mit sich führte, wurde eine stabile 20222-Version gewählt.

\subsection{Blender 4.3.2}
Blender dient als Bearbeitungstool für die 3D-Modelle aus den hinzugenommenen Unity Assets. Die aktuelle Version zu Projektstart war die 4.3.2 Version- welche über den gesamten Bearbeitungszeitraum verwendet wurde. Außerdem bietet Unity einen Blender Direktimport an, wodurch keine \ac{FBX} oder \ac{OBJ} Dateien aus den Blenderdateien exportiert und in Unity importiert werden mussten.

\subsection{NuGetForUnity 4.1.1}
NuGetForUnity ist ein für Unity entwickelter NuGet-Client (vgl. \cite{noauthor_nuget_nodate}) über den zusätzliche funktionale Pakete für Unity installiert werden kann (vgl. \cite{mccarthy_glitchenzonugetforunity_2025}). Er war nötig, um ein nicht über Unity erworbenes Package in Unity nutzen zu können. Die aktuelle Version zum Bearbeitungsstart war die 4.1.1 Version, welche bis zum Ende genutzt wurde.

\subsection{Newtonsoft.Json 13.03}
Das erste Package, welches über NuGetForUnity installiert wurde ist Newtonsoft.Json, durch welches über den WebSocket übertragene JSON-Daten leicht deserialisiert und serialisiert werden können (vgl. \cite{newtonsoft_jsonnet_nodate}). Die aktuelle Version im NuGet-Paketverwaltungstool war die 13.03.

\subsection{WebSocketSharp-netstandard 1.0.1}
Derzeit gibt es einige Netzwerk-Integrationen für Unity, bspw. Mirror (vgl. \cite{noauthor_mirror_nodate}) oder Netcode for GameObjects (vgl. \cite{noauthor_about_2025}). Durch beiden Packages wäre jedoch die Netzwerk-Topologie starrer und die Entwicklung nach eigener Vorstellung wäre ebenfalls eingeschränkter. Daher wurde über NuGetForUnity das WebSocketSharp-netstandard Paket installiert, welches eine direkte Kommunikation mit einem WebSocket-Server ermöglicht (vgl. \cite{pingman_tools_pingmantoolswebsocket-sharp_2025}), da bislang existierende Integration mit Unity nicht mehr unterstützt werden. Die derzeit installierte und zum Projektstart installierbare Version ist die 1.0.1.

\subsection{AI Navigation 1.1.5}
Da sich der Avatar des Players innerhalb der Spielwelt per Touch-Click auf den Bildschirm an die angeklickte stelle bewegen soll, muss ein \ac{AI}-Agent eingebaut werden, der das Avatar Spielobjekt an die gewünschte Stelle bewegt. In Unity kann dafür das NavMesh System verwendet werden, welches ein Pathfinding-System implementiert, wodurch ein automatisiertes Bewegen eines Agents durch eine Zielposition integriert werden kann. Das Paket in Unity heißt dafür \ac{AI}-Navigation. Die aktuelle Version zum Start des Projekts ist die 1.1.5.

\subsection{Cinemachine 2.10.1}


\subsection{Universal RP 14.0.11}

\subsection{Unity UI 1.0.0}

\subsection{TextMeshPro 3.0.9}

\subsection{Input System 1.7.0}

\subsection{FBX Exporter 4.2.1}

\subsection{Unity Assets}

\begin{itemize}  
    \item Astronaut Model von \cite{quaternius_astronaut_nodate}
    \item Chair Pack - 3D Low Poly Office Furniture 1.0 \cite{fast_mesh_chair_nodate}
    \item low poly WD | 3D Props 1.1 \cite{squid_low_nodate}
    \item Adventure Game Environment Pack | URP | 3D Sci-Fi 1.0 \cite{unity_technologies_adventure_nodate-1}
    \item Adventure - Sample Game | Tutorials 3.0 \cite{unity_technologies_adventure_nodate}
    \item Bedroom / Interior - Low Poly assets | 3D Interior 1.1.6 \cite{fries_and_seagull_bedroom_nodate}
    \item Big Furniture Pack | 3D Furniture 1.3 \cite{vertex_studio_big_nodate}
    \item Chair pack - 3D Low Poly Office Furniture - Created with FastMesh Asset | 3D Furniture 1.0 \cite{fast_mesh_chair_nodate}
    \item Fantasy Cemetery \& Necropolis Pack Lite: 3D Assets for RPG and Adventure Games | 3D Fantasy 1.2 \cite{emaceart_fantasy_nodate}
    \item Free Wood Door Pack | 3D Interior 1.0 \cite{biostart_free_nodate}
    \item Kitchen Appliance - Low Poly | 3D Electronics 1.02 \cite{alstra_infinite_kitchen_nodate}
    \item Lowpoly Dungeon Assets | 3D Dungeons 1.0 \cite{kunniki_lowpoly_nodate}
    \item Low Poly Dungeon Generator | 3D Dungeons 1.0 \cite{mysticforge_low_nodate}
    \item Low Poly Dungeons Lite | 3D Dungeons 1.11 \cite{justcreate_low_nodate-1}
    \item Low Poly Simple Medieval Props | 3D Props 1.0 \cite{justcreate_low_nodate}
    \item LowPoly Server Room Props | 3D Environments 1.0 \cite{ipoly3d_lowpoly_nodate}
    \item Melon's Low Poly Office | 3D Interior 1.1.1 \cite{mistyczny_arbuz_melons_nodate}
    \item Office Pack - Free | 3D Interior 1.02 \cite{nappin_office_nodate}
    \item Ultimate Low Poly Dungeon | 3D Dungeons 2.0 \cite{broken_vector_ultimate_nodate}
\end{itemize}

\subsection{Docker}
\cite{noauthor_docker_2025}

\subsection{MongoDB - Docker Image}
\cite{noauthor_mongo_nodate}
\cite{mongodb_mongodbnode-mongodb-native_2025}

\subsection{Express.js Webserver 5.1.0}
\cite{noauthor_express_nodate}

\subsection{Node Version 20.18.1}
\cite{noauthor_nodejs_nodate}

\subsection{User Interface Inspirationen}

\begin{itemize}
    \item Vorlage für SciFi \ac{UI}s von \cite{pchvector_free_nodate}
    \item Vorlage für Low-Poly Feder von \cite{masud_download_nodate}
    [TODO: Hier fehlen noch die Dumps von CHat, die nachgemalt wurden]
\end{itemize}

\section{Aufbau des Prototyps}



\section{Herausforderungen in der Umsetzung}
% erste Ansätze im Levelbuilding erwähnen

% hier kommt das placing also die positionen in der spielwelt

% dann drauf bezogen das mit den slots, dass die ne position haben später auch fürs setzen wichtig
% das mit den collidern, was man auch anders umsetzen kann noch, das noch erwähnen






% bei umsetzung müssen die 3d und ar anwendung vorgestellt werden vom watcher
% hier muss ein bezg auf das paper mit den steuerungen für touch erwähnt werden


% die anwendung vom playewr

\section{Probleme in der Umsetzung}

% AR

% Gerätefindung im selben Netzwerk